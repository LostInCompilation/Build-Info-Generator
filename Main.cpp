/********************************************************************/
/*																	*/
/*						(C) 2021 Marc Schöndorf						*/
/*																	*/
/*	Automatically creates a header file with						*/
/*	incrementing build number and time info							*/
/********************************************************************/
/*		     Updated 2021, original version from 2019				*/
/********************************************************************/

#include <iostream>
#include <fstream>
#include <sstream>
#include <cstdint>
#include <string>
#include <vector>
#include <filesystem>
#include <Windows.h>

// Macro names (should be ASCII, because the search function currently doesn't find Unicode chars. The file is still written as UTF-8)
const std::string _MacroPause = "BUILD_INFO_GENERATOR_PAUSE";

const std::string _MacroBuildNumber = "AUTOMATIC_BUILD_INFO_NUMBER";

const std::string _MacroBuildDay = "AUTOMATIC_BUILD_INFO_DAY";
const std::string _MacroBuildMonth = "AUTOMATIC_BUILD_INFO_MONTH";
const std::string _MacroBuildYear = "AUTOMATIC_BUILD_INFO_YEAR";

const std::string _MacroBuildHour = "AUTOMATIC_BUILD_INFO_HOUR";
const std::string _MacroBuildMinute = "AUTOMATIC_BUILD_INFO_MINUTE";
const std::string _MacroBuildSecond = "AUTOMATIC_BUILD_INFO_SECOND";

// File header to write (UTF-8)
const std::string _FileHeader =
u8"/********************************************************************/\n" \
u8"/*                                                                  */\n" \
u8"/*                 Generated by Build Info Generator                */\n" \
u8"/*                                                                  */\n" \
u8"/*                      (C) 2021 Marc Schöndorf                     */\n" \
u8"/*                                                                  */\n" \
u8"/*  All modifications to this file                                  */\n" \
u8"/*  will be replaced on next run.                                   */\n" \
u8"/********************************************************************/\n\n" \
u8"#pragma once\n\n" \
u8"// To pause updating this file, set \"" + _MacroPause + "\" to \"1\".\n" \
u8"#define " + _MacroPause + " 0\n\n" \
u8"// Generated info\n";


// Helper enum for "SearchAndParseMacroInCurrentLine" function
enum class ReturnCode : uint8_t
{
	NotFound = 0,
	ParseError = 1,
	Success = 2
};

// Search if "macroName" is in "currentLine", if yes parses the macro value to an integer.
ReturnCode SearchAndParseMacroInCurrentLine(const std::string& currentLine, const std::string_view& macroNameView, uint64_t& parsedIntegerOut)
{
	// Search if macro name is in the line
	const size_t macroNamePos = currentLine.find(macroNameView);
	if (macroNamePos == std::string::npos)
		return ReturnCode::NotFound; // Not found, return

	// Macro found
	// Search for first space after macro name, beginning at first char of macro name. The number begins after the found space
	const size_t spacePos = currentLine.find(' ', macroNamePos);
	if (spacePos == std::string::npos)
	{
		// Space not found
		std::cout << "[ERROR]: Unknown Syntax after \"" << macroNameView << "\"! Expected a space. File corrupted?" << std::endl;
		return ReturnCode::ParseError;
	}

	// Get the number (it begins one char after found space until end of line)
	std::string numberString = currentLine.substr(spacePos + 1);
	if (numberString == "")
	{
		// No value found
		std::cout << "[ERROR]: Unknown Syntax after \"" << macroNameView << "\"! Expected a value. File corrupted?" << std::endl;
		return ReturnCode::ParseError;
	}

	// Remove \n or \r at the end of line
	numberString.erase(std::remove(numberString.begin(), numberString.end(), '\n'), numberString.end());
	numberString.erase(std::remove(numberString.begin(), numberString.end(), '\r'), numberString.end());

	// Try converting the string to integer
	try {
		parsedIntegerOut = std::stoull(numberString);
	}
	catch (...) {
		std::cout << "[ERROR]: Could not parse macro value! Conversion failed. File corrupted?" << std::endl;
		return ReturnCode::ParseError;
	}

	return ReturnCode::Success;
}

// Read a build info file and return the parsed information
bool ReadBuildInfoFile(const std::wstring_view& filenameView, uint64_t& buildNumberOut, bool& pauseOut)
{
	// Open file
	std::ifstream buildInfoFile(filenameView);
	if (!buildInfoFile.is_open())
	{
		// Not found, file may be corrupted or encoded
		std::cout << "[ERROR]: File seems to exist but it could not be opened for reading! Is path a folder?" << std::endl;
		return false;
	}

	// Read file
	bool		buildNumberMacroFoundAndParsed = false;
	bool		pauseMacroFoundAndParsed = false;

	uint64_t	parsedBuildNumber = 0;
	uint64_t	parsedPauseValue = 0;

	std::string currentLine = "";
	while (std::getline(buildInfoFile, currentLine)) // Read file line by line
	{
		// Skip all empty lines and lines that don't start with '#'
		if (currentLine.size() == 0 || currentLine[0] != '#')
			continue;

		// Search and parse _MacroBuildNumber (only if it wasn't found yet)
		if (!buildNumberMacroFoundAndParsed)
		{
			const ReturnCode ret = SearchAndParseMacroInCurrentLine(currentLine, _MacroBuildNumber, parsedBuildNumber);

			if (ret == ReturnCode::Success)
			{
				// Successfully found parsed the macro
				buildNumberMacroFoundAndParsed = true;
			}
			else if (ret == ReturnCode::ParseError)
			{
				// Error while parsing found macro name. Abort current parsing and exit
				buildInfoFile.close();
				return false;
			} // Do nothing on "not found", go to next line
		}

		// Search and parse _MacroPause (only if it wasn't found yet)
		if (!pauseMacroFoundAndParsed)
		{
			const ReturnCode ret = SearchAndParseMacroInCurrentLine(currentLine, _MacroPause, parsedPauseValue);

			if (ret == ReturnCode::Success)
			{
				// Successfully parsed the macro
				pauseMacroFoundAndParsed = true;
			}
			else if (ret == ReturnCode::ParseError)
			{
				// Error while parsing found macro name. Abort current parsing and exit
				buildInfoFile.close();
				return false;
			} // Do nothing on "not found", go to next line
		}

		// Break loop when both macros are found, since there is no point in searching any further
		if (buildNumberMacroFoundAndParsed && pauseMacroFoundAndParsed)
			break;
	}

	// Close the file
	buildInfoFile.close();

	// Check if build number macro was found and parsed. This macro is needed, however the pause macro is optional.
	if (buildNumberMacroFoundAndParsed)
	{
		// Output build number
		buildNumberOut = parsedBuildNumber;
	}
	else
	{
		// Build number macro not found, file may be corrupted
		std::cout << "[ERROR]: Macro \"" << _MacroBuildNumber << "\" not found! File corrupted?" << std::endl;
		return false;
	}

	// Check if optional pause macro was found, if not assume pause is disabled
	if (pauseMacroFoundAndParsed)
		pauseOut = parsedPauseValue == 0 ? false : true;
	else
		pauseOut = false;

	return true;
}

// Return the number as string with fixed digit count
std::string FixedWidth(const int64_t& integer)
{
	std::ostringstream ss;
	ss << std::setw(2) << std::setfill('0') << integer;

	return ss.str();
}

// Assemble the string which contains all macro defines (used by WriteBuildNumberFile)
std::string AssembleMacroValues(const uint64_t& buildNumber, const bool& enableTime)
{
	// Assemble string
	std::string assembled = u8"";

	assembled += u8"#define " + _MacroBuildNumber + u8" " + std::to_string(buildNumber) + u8"\n\n";

	if (enableTime)
	{
		// Get current date and time
		std::tm tm = {};
		const auto timePoint = std::chrono::system_clock::now();
		const std::time_t timeT = std::chrono::system_clock::to_time_t(timePoint);
		localtime_s(&tm, &timeT);

		// Write time and date
		assembled += u8"#define " + _MacroBuildDay + u8" " + FixedWidth(tm.tm_mday) + u8"\n";
		assembled += u8"#define " + _MacroBuildMonth + u8" " + FixedWidth(tm.tm_mon + 1LL) + u8"\n";
		assembled += u8"#define " + _MacroBuildYear + u8" " + FixedWidth(tm.tm_year + 1900LL) + u8"\n\n";

		assembled += u8"#define " + _MacroBuildHour + u8" " + FixedWidth(tm.tm_hour) + u8"\n";
		assembled += u8"#define " + _MacroBuildMinute + u8" " + FixedWidth(tm.tm_min) + u8"\n";
		assembled += u8"#define " + _MacroBuildSecond + u8" " + FixedWidth(tm.tm_sec) + u8"\n\n";
	}

	return assembled;
}

// Writes a build info file (UTF-8)
bool WriteBuildInfoFile(const std::wstring_view& filenameView, const uint64_t& buildNumber, const bool& enableTime)
{
	// Open file
	std::ofstream buildInfoFile(filenameView);
	if (!buildInfoFile.is_open())
	{
		std::cout << "[ERROR]: Could not open file for writing! Do you have write permissions?" << std::endl;
		return false;
	}

	// Assemble all macro defines and values as std::string for writing
	const std::string assembledMacros = AssembleMacroValues(buildNumber, enableTime);

	// Write file header
	buildInfoFile.write(_FileHeader.data(), _FileHeader.size());

	// Write macro defines and values
	buildInfoFile.write(assembledMacros.data(), assembledMacros.size());

	// Write EOF signal
	const std::string eofSignal = u8"/*----------------- End of generated file -----------------*/\n";
	buildInfoFile.write(eofSignal.data(), eofSignal.size());

	// Check if write succeeded
	if (!buildInfoFile.good())
	{
		std::cout << "[ERROR]: Writing to file failed! File may be corrupted. Do you have write permissions?" << std::endl;

		buildInfoFile.close();
		return false;
	}

	// Close file
	buildInfoFile.close();

	return true;
}

// Get the arguments as wide strings (UTF16)
std::vector<std::wstring> GetCommandLineArguments()
{
	// Get arguments as Unicode UTF16
	LPWSTR* argList = nullptr;
	int32_t argc = 0;
	argList = CommandLineToArgvW(GetCommandLineW(), &argc);

	if (argList == nullptr)
	{
		std::cout << "[ERROR]: Could not parse command line arguments!" << std::endl;
		return std::vector<std::wstring>();
	}

	std::vector<std::wstring> commandArguments;
	for (int32_t i = 0; i < argc; i++)
		commandArguments.push_back(argList[i]);

	LocalFree(argList);

	return commandArguments;
}

int main()
{
	std::cout << "AutomaticBuildNumber: ";

	// Get command line arguments
	const std::vector<std::wstring> commandArguments = GetCommandLineArguments();

	if (commandArguments.size() < 2)
	{
		std::cout << "Wrong command line arguments specified! Usage: AutomaticBuildNumber.exe \"target_file\" [/time]" << std::endl;
		return -1;
	}

	// Parse arguments. No advanced parser needed, because only one additional argument is supported
	const std::wstring filename = commandArguments[1]; // Get filename
	bool enableTime = false;

	// Check for time switch [/time]
	if (commandArguments.size() > 2)
	{
		if (commandArguments[2] == L"/time")
			enableTime = true;
	}

	// Print update
	std::cout << "Generating... ";

	// Check if file already exists
	if (std::filesystem::exists(filename))
	{
		// File found
		uint64_t buildNumber = 0;
		bool pauseUpdates = false;

		// Read build info from file
		if (!ReadBuildInfoFile(filename, buildNumber, pauseUpdates))
			return -1; // Read failed, error message got printed inside function

		// Check if pause macro is enabled
		if (pauseUpdates)
		{
			// Skip all updates and exit
			std::cout << "[INFO]: Pause is enabled, no updates on file performed. [DONE]" << std::endl;
			return 0;
		}

		// Increment build number
		buildNumber++;

		// Write updated file
		if (!WriteBuildInfoFile(filename, buildNumber, enableTime))
			return -1; // Write failed, error message got printed inside function
	}
	else
	{
		// File does not exist. Create new file with build number zero
		if (!WriteBuildInfoFile(filename, 0, enableTime))
			return -1; // Write failed, error message got printed inside function
	}

	std::cout << "[DONE]" << std::endl;

	return 0;
}
