/********************************************************************/
/*																	*/
/*						(C) 2021 Marc Schöndorf						*/
/*																	*/
/*	Automatically creates a header file with						*/
/*	incrementing build number and time info							*/
/********************************************************************/
/*		     Updated 2021, original version from 2019				*/
/********************************************************************/

#include <iostream>
#include <fstream>
#include <sstream>
#include <cstdint>
#include <string>
#include <vector>
#include <filesystem>
#include <Windows.h>

// Macro names (should be ASCII, because the search function currently doesn't find Unicode chars. The file is still written as UTF-8)
const std::string _MacroPause = "BUILD_INFO_GENERATOR_PAUSE";

const std::string _MacroBuildNumber = "BUILD_INFO_GENERATOR_BUILD_NUMBER";

const std::string _MacroBuildDay = "BUILD_INFO_GENERATOR_DAY";
const std::string _MacroBuildMonth = "BUILD_INFO_GENERATOR_MONTH";
const std::string _MacroBuildYear = "BUILD_INFO_GENERATOR_YEAR";

const std::string _MacroBuildHour = "BUILD_INFO_GENERATOR_HOUR";
const std::string _MacroBuildMinute = "BUILD_INFO_GENERATOR_MINUTE";
const std::string _MacroBuildSecond = "BUILD_INFO_GENERATOR_SECOND";

// File header to write (UTF-8)
const std::string _FileHeader =
u8"/********************************************************************/\n" \
u8"/*                                                                  */\n" \
u8"/*                 Generated by Build Info Generator                */\n" \
u8"/*                                                                  */\n" \
u8"/*                      (C) 2021 Marc Schöndorf                     */\n" \
u8"/*                                                                  */\n" \
u8"/*  All modifications to this file                                  */\n" \
u8"/*  will be replaced on next run.                                   */\n" \
u8"/********************************************************************/\n\n" \
u8"#pragma once\n\n" \
u8"// To disable updates to this file, set \"" + _MacroPause + "\" to \"1\".\n" \
u8"#define " + _MacroPause + " 0\n\n" \
u8"// Generated info\n";


// Parse the macro in the current line
bool ParseMacroInCurrentLine(const std::string_view& currentLineView, const size_t& startPoint, uint64_t& parsedIntegerOut)
{
	// Search for first space beginning at first char of macro name (startPoint). The number begins after the found space
	const size_t spacePos = currentLineView.find(' ', startPoint);
	if (spacePos == std::string::npos)
	{
		// Space not found
		std::cout << "[ERROR]: Unknown Syntax after \"" << currentLineView.substr(startPoint) << "\"! Expected a space. File may be damaged." << std::endl;
		return false;
	}

	// Get the number (it begins one char after found space until end of line)
	std::string numberString = currentLineView.substr(spacePos + 1).data();
	if (numberString == "")
	{
		// No value found
		std::cout << "[ERROR]: Unknown Syntax after \"" << currentLineView.substr(startPoint) << "\"! Expected a value. File may be damaged." << std::endl;
		return false;
	}

	// Remove \n or \r at the end of line
	numberString.erase(std::remove(numberString.begin(), numberString.end(), '\n'), numberString.end());
	numberString.erase(std::remove(numberString.begin(), numberString.end(), '\r'), numberString.end());

	// Try converting the string to integer
	try {
		parsedIntegerOut = std::stoull(numberString);
	}
	catch (...) {
		std::cout << "[ERROR]: Could not parse value of \"" << currentLineView.substr(startPoint) << "\". File may be damaged." << std::endl;
		return false;
	}

	return true;
}

// Read a build info file and return the parsed information. The function aborts when a macro cannot be parsed
bool ReadBuildInfoFile(const std::wstring_view& filenameView, uint64_t& buildNumberOut, bool& pauseEnabledOut)
{
	// Open file
	std::ifstream buildInfoFile(filenameView);
	if (!buildInfoFile.is_open())
	{
		// Not found, file may be corrupted or encoded
		std::cout << "[ERROR]: File seems to exist but it could not be opened for reading! Is path a folder?" << std::endl;
		return false;
	}

	// Read file
	std::pair<bool, uint64_t> macroBuildNumberResult(false, 0); // (found, data)
	std::pair<bool, uint64_t> macroPauseResult(false, 0); // (found, data)
	std::string currentLine = "";

	while (std::getline(buildInfoFile, currentLine)) // Read file line by line
	{
		// Skip all empty lines and lines that don't start with '#'
		if (currentLine.size() == 0 || currentLine[0] != '#')
			continue;

		// Search for build number macro in current line if it was not found yet
		if (!macroBuildNumberResult.first) // Already found?
		{
			const size_t macroNameStartPoint = currentLine.find(_MacroBuildNumber);
			if (macroNameStartPoint != std::string::npos)
			{
				// Macro found, try to parse it
				if (!ParseMacroInCurrentLine(currentLine, macroNameStartPoint, macroBuildNumberResult.second))
				{
					// Parse failed, error message got printed inside function
					buildInfoFile.close();
					return false;
				}

				// Macro found and parsed successfully
				macroBuildNumberResult.first = true;
			}
		}

		// Search for pause macro in current line if it was not found yet
		if (!macroPauseResult.first)
		{
			const size_t macroNameStartPoint = currentLine.find(_MacroPause);
			if (macroNameStartPoint != std::string::npos)
			{
				// Macro found, try to parse it
				if (!ParseMacroInCurrentLine(currentLine, macroNameStartPoint, macroPauseResult.second))
				{
					// Parse failed, error message got printed inside function
					buildInfoFile.close();
					return false;
				}

				// Macro found and parsed successfully
				macroPauseResult.first = true;
			}
		}

		// Break loop when both macros are found and parsed, since there are not more than those two macros
		if (macroBuildNumberResult.first && macroPauseResult.first)
			break;
	}

	// Close the file
	buildInfoFile.close();

	// Check if build number macro was found (necessary)
	if (!macroBuildNumberResult.first)
	{
		std::cout << "[ERROR]: Macro \"" << _MacroBuildNumber << "\" not found! File may be damaged." << std::endl;
		return false;
	}

	// Set output value
	buildNumberOut = macroBuildNumberResult.second;

	// Check if pause macro was found (optional). If not, set pause to disabled
	if (macroPauseResult.first)
		pauseEnabledOut = macroPauseResult.second == 0 ? false : true;
	else
		pauseEnabledOut = false;

	return true;
}

// Return the number as string with fixed digit count
std::string FixedWidth(const int64_t& integer)
{
	std::ostringstream ss;
	ss << std::setw(2) << std::setfill('0') << integer;

	return ss.str();
}

// Assemble the string which contains all macro defines (used by WriteBuildNumberFile)
std::string AssembleMacroValues(const uint64_t& buildNumber, const bool& enableTime)
{
	// Assemble string
	std::string assembled = u8"";

	assembled += u8"#define " + _MacroBuildNumber + u8" " + std::to_string(buildNumber) + u8"\n\n";

	if (enableTime)
	{
		// Get current date and time
		std::tm tm = {};
		const auto timePoint = std::chrono::system_clock::now();
		const std::time_t timeT = std::chrono::system_clock::to_time_t(timePoint);
		localtime_s(&tm, &timeT);

		// Write time and date
		assembled += u8"#define " + _MacroBuildDay + u8" " + FixedWidth(tm.tm_mday) + u8"\n";
		assembled += u8"#define " + _MacroBuildMonth + u8" " + FixedWidth(tm.tm_mon + 1LL) + u8"\n";
		assembled += u8"#define " + _MacroBuildYear + u8" " + FixedWidth(tm.tm_year + 1900LL) + u8"\n\n";

		assembled += u8"#define " + _MacroBuildHour + u8" " + FixedWidth(tm.tm_hour) + u8"\n";
		assembled += u8"#define " + _MacroBuildMinute + u8" " + FixedWidth(tm.tm_min) + u8"\n";
		assembled += u8"#define " + _MacroBuildSecond + u8" " + FixedWidth(tm.tm_sec) + u8"\n\n";
	}

	return assembled;
}

// Writes a build info file (UTF-8)
bool WriteBuildInfoFile(const std::wstring_view& filenameView, const uint64_t& buildNumber, const bool& enableTime)
{
	// Open file
	std::ofstream buildInfoFile(filenameView);
	if (!buildInfoFile.is_open())
	{
		std::cout << "[ERROR]: Could not open file for writing! Do you have write permissions?" << std::endl;
		return false;
	}

	// Assemble all macro defines and values as std::string for writing
	const std::string assembledMacros = AssembleMacroValues(buildNumber, enableTime);

	// Write file header
	buildInfoFile.write(_FileHeader.data(), _FileHeader.size());

	// Write macro defines and values
	buildInfoFile.write(assembledMacros.data(), assembledMacros.size());

	// Write EOF signal
	const std::string eofSignal = u8"/********************** End of generated file **********************/";
	buildInfoFile.write(eofSignal.data(), eofSignal.size());

	// Check if write succeeded
	if (!buildInfoFile.good())
	{
		std::cout << "[ERROR]: Writing to file failed! File may be damaged. Do you have write permissions?" << std::endl;

		buildInfoFile.close();
		return false;
	}

	// Close file
	buildInfoFile.close();

	return true;
}

// Get the arguments as wide strings (UTF16)
std::vector<std::wstring> GetCommandLineArguments()
{
	// Get arguments as Unicode UTF16
	LPWSTR* argList = nullptr;
	int32_t argc = 0;
	argList = CommandLineToArgvW(GetCommandLineW(), &argc);

	if (argList == nullptr)
	{
		std::cout << "[ERROR]: Could not parse command line arguments!" << std::endl;
		return std::vector<std::wstring>();
	}

	std::vector<std::wstring> commandArguments;
	for (int32_t i = 0; i < argc; i++)
		commandArguments.push_back(argList[i]);

	LocalFree(argList);

	return commandArguments;
}

// Print help text about command line arguments
void PrintHelpText()
{
	std::cout << std::endl << "Usage:" << std::endl;
	std::cout << "	A" << std::endl;
	std::cout << "	B" << std::endl;
	std::cout << "	C" << std::endl;
	std::cout << "	D" << std::endl;
}

// Parse all command line arguments and output result
bool ParseCommandLineArguments(std::vector<std::wstring> arguments, std::wstring& filenameOut, bool& enableTimeOut, bool& resetOut)
{
	if (arguments.size() <= 1)
	{
		// No user arguments passed, only executable path from OS. Show help
		std::cout << "No command line arguments specified!" << std::endl;

		PrintHelpText();
		return false;
	}

	// Vector is guaranteed to have at least two elements. Get the second element (filename) directly, because it's required
	filenameOut = arguments[1];

	// Check if additional user arguments are present
	if (arguments.size() <= 2)
		return true; // No additional arguments present

	// Remove first argument (executable path from OS), since it's not needed
	arguments.erase(arguments.begin());

	// Parse all optional user arguments one by one
	for (const auto& arg : arguments)
	{

	}

	return true;
}

// Main routine
int main()
{
	std::cout << "Build Info Generator: ";

	// Get command line arguments
	const std::vector<std::wstring> commandArguments = GetCommandLineArguments();

	// Parse user arguments
	if (ParseCommandLineArguments(commandArguments, filename, enableTime, reset))
		return -1; // Parse failed, error message got print inside function




	// Parse arguments. No advanced parser needed, because only one additional argument is supported
	const std::wstring filename = commandArguments[1]; // Get filename
	bool enableTime = false;

	// Check for time switch [/time]
	if (commandArguments.size() > 2)
	{
		if (commandArguments[2] == L"/time")
			enableTime = true;
	}

	// Print update
	std::cout << "Generating... ";

	// Check if file already exists
	if (std::filesystem::exists(filename))
	{
		// File found
		uint64_t buildNumber = 0;
		bool pauseUpdates = false;

		// Read build info from file
		if (!ReadBuildInfoFile(filename, buildNumber, pauseUpdates))
			return -1; // Read failed, error message got printed inside function

		// Check if pause macro is enabled
		if (pauseUpdates)
		{
			// Skip all updates and exit
			std::cout << "[INFO]: Pause is enabled, no updates on file performed. [DONE]" << std::endl;
			return 0;
		}

		// Increment build number
		buildNumber++;

		// Write updated file
		if (!WriteBuildInfoFile(filename, buildNumber, enableTime))
			return -1; // Write failed, error message got printed inside function
	}
	else
	{
		// File does not exist. Create new file with build number zero
		if (!WriteBuildInfoFile(filename, 0, enableTime))
			return -1; // Write failed, error message got printed inside function
	}

	std::cout << "[DONE]" << std::endl;

	return 0;
}
