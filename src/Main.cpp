/*
MIT License

Copyright (c) 2021 Marc Schöndorf

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

/********************************************************************/
/*                                                                  */
/*                      (C) 2021 Marc Schöndorf                     */
/*                            See license                           */
/*                                                                  */
/*  Automatically creates a header file with                        */
/*  incrementing build number and time info                         */
/********************************************************************/
/*          Reworked 2021, original version from 2019.              */
/********************************************************************/

#include <iostream>
#include <fstream>
#include <sstream>
#include <cstdint>
#include <string>
#include <vector>
#include <filesystem>
#include <Windows.h>

// Macro names (should be ASCII, because currently the macro parser can't handle Unicode chars. The file is still written as UTF-8)
const std::string _MacroPause = "BUILD_INFO_GENERATOR_PAUSE";

const std::string _MacroBuildNumber = "BUILD_INFO_GENERATOR_BUILD_NUMBER";

const std::string _MacroBuildDay = "BUILD_INFO_GENERATOR_DAY";
const std::string _MacroBuildMonth = "BUILD_INFO_GENERATOR_MONTH";
const std::string _MacroBuildYear = "BUILD_INFO_GENERATOR_YEAR";
const std::string _MacroBuildDateString = "BUILD_INFO_GENERATOR_DATE_STR";

const std::string _MacroBuildHour = "BUILD_INFO_GENERATOR_HOUR";
const std::string _MacroBuildMinute = "BUILD_INFO_GENERATOR_MINUTE";
const std::string _MacroBuildSecond = "BUILD_INFO_GENERATOR_SECOND";
const std::string _MacroBuildTimeString = "BUILD_INFO_GENERATOR_TIME_STR";

// File header to write (UTF-8)
const std::string _FileHeader =
u8"/********************************************************************/\n" \
u8"/*                                                                  */\n" \
u8"/*                 Generated by Build Info Generator                */\n" \
u8"/*                                                                  */\n" \
u8"/*  All modifications to this file                                  */\n" \
u8"/*  will be replaced on next run.                                   */\n" \
u8"/********************************************************************/\n\n" \
u8"#pragma once\n\n" \
u8"// To disable updates to this file, set \"" + _MacroPause + u8R"(" to "1".)" + u8"\n" \
u8"#define " + _MacroPause + u8" 0\n\n" \
u8"// Generated info\n";


// Parse the macro in the current line
bool ParseMacroInCurrentLine(const std::string_view& currentLineView, const size_t& startPoint, uint64_t& parsedInteger_out)
{
	// Search for first space beginning at first char of macro name (startPoint). The number begins after the found space
	const size_t spacePos = currentLineView.find(' ', startPoint);
	if (spacePos == std::string::npos)
	{
		// Space not found
		std::cout << "[ERROR]: Unknown Syntax after \"" << currentLineView.substr(startPoint) << "\"! Expected a space. File may be damaged, try \"/reset\"." << std::endl;
		return false;
	}

	// Get the number (it begins one char after found space until end of line)
	std::string numberString = currentLineView.substr(spacePos + 1).data();
	if (numberString == "")
	{
		// No value found
		std::cout << "[ERROR]: Unknown Syntax after \"" << currentLineView.substr(startPoint) << "\"! Expected a value. File may be damaged, try \"/reset\"." << std::endl;
		return false;
	}

	// Remove \n or \r at the end of line
	numberString.erase(std::remove(numberString.begin(), numberString.end(), '\n'), numberString.end());
	numberString.erase(std::remove(numberString.begin(), numberString.end(), '\r'), numberString.end());

	// Try converting the string to integer
	try {
		parsedInteger_out = std::stoull(numberString);
	}
	catch (...) {
		std::cout << "[ERROR]: Could not parse value of \"" << currentLineView.substr(startPoint) << "\". File may be damaged, try \"/reset\"." << std::endl;
		return false;
	}

	return true;
}

// Read a build info file and return the parsed information. The function aborts when a macro cannot be parsed
bool ReadBuildInfoFile(const std::wstring_view& filenameView, uint64_t& buildNumber_out, bool& pauseEnabled_out)
{
	// Open file
	std::ifstream buildInfoFile(filenameView);
	if (!buildInfoFile.is_open())
	{
		// Not found, file may be corrupted or encoded
		std::cout << "[ERROR]: File seems to exist but it could not be opened for reading!" << std::endl;
		return false;
	}

	// Read file
	std::pair<bool, uint64_t> macroBuildNumberResult(false, 0); // (found, data)
	std::pair<bool, uint64_t> macroPauseResult(false, 0); // (found, data)
	std::string currentLine = "";

	while (std::getline(buildInfoFile, currentLine)) // Read file line by line
	{
		// Skip all empty lines and lines that don't start with '#'
		if (currentLine.size() == 0 || currentLine[0] != '#')
			continue;

		// Search for build number macro in current line if it was not found yet
		if (!macroBuildNumberResult.first) // Already found?
		{
			const size_t macroNameStartPoint = currentLine.find(_MacroBuildNumber);
			if (macroNameStartPoint != std::string::npos)
			{
				// Macro found, try to parse it
				if (!ParseMacroInCurrentLine(currentLine, macroNameStartPoint, macroBuildNumberResult.second))
				{
					// Parse failed, error message got printed inside function
					buildInfoFile.close();
					return false;
				}

				// Macro found and parsed successfully
				macroBuildNumberResult.first = true;
			}
		}

		// Search for pause macro in current line if it was not found yet
		if (!macroPauseResult.first) // Already found?
		{
			const size_t macroNameStartPoint = currentLine.find(_MacroPause);
			if (macroNameStartPoint != std::string::npos)
			{
				// Macro found, try to parse it
				if (!ParseMacroInCurrentLine(currentLine, macroNameStartPoint, macroPauseResult.second))
				{
					// Parse failed, error message got printed inside function
					buildInfoFile.close();
					return false;
				}

				// Macro found and parsed successfully
				macroPauseResult.first = true;
			}
		}

		// Break loop when both macros are found and parsed, since there are not more than those two macros
		if (macroBuildNumberResult.first && macroPauseResult.first)
			break;
	}

	// Close the file
	buildInfoFile.close();

	// Check if build number macro was found (necessary)
	if (!macroBuildNumberResult.first)
	{
		std::cout << "[ERROR]: Macro \"" << _MacroBuildNumber << "\" not found! File may be damaged, try \"/reset\"." << std::endl;
		return false;
	}

	// Set output value
	buildNumber_out = macroBuildNumberResult.second;

	// Check if pause macro was found (optional). If not, set pause to disabled
	if (macroPauseResult.first)
		pauseEnabled_out = macroPauseResult.second == 0 ? false : true;
	else
		pauseEnabled_out = false;

	return true;
}

// Return the number as string with fixed digit count
std::string ToStringFixedWidth(const int64_t& integer, const uint8_t& width = 2)
{
	std::ostringstream ss;
	ss << std::setw(width) << std::setfill('0') << integer;

	return ss.str();
}

// Assemble the string which contains all macro defines (used by WriteBuildNumberFile)
std::string AssembleMacroValues(const uint64_t& buildNumber, const bool& enableTime)
{
	// Assemble string
	std::string assembled = u8"#define " + _MacroBuildNumber + u8" " + std::to_string(buildNumber) + u8"\n\n";

	if (enableTime)
	{
		// Get current date and time
		std::tm tm = {};
		const auto timePoint = std::chrono::system_clock::now();
		const std::time_t timeT = std::chrono::system_clock::to_time_t(timePoint);
		localtime_s(&tm, &timeT);

		// Write time and date
		assembled += u8"#define " + _MacroBuildDay + u8" " + ToStringFixedWidth(tm.tm_mday) + u8"\n";
		assembled += u8"#define " + _MacroBuildMonth + u8" " + ToStringFixedWidth(tm.tm_mon + 1LL) + u8"\n";
		assembled += u8"#define " + _MacroBuildYear + u8" " + ToStringFixedWidth(tm.tm_year + 1900LL) + u8"\n";
		assembled += u8"#define " + _MacroBuildDateString + u8" \"" + ToStringFixedWidth(tm.tm_mday) + u8"." +
			ToStringFixedWidth(tm.tm_mon + 1LL) + u8"." + ToStringFixedWidth(tm.tm_year + 1900LL) + u8"\"\n\n";

		assembled += u8"#define " + _MacroBuildHour + u8" " + ToStringFixedWidth(tm.tm_hour) + u8"\n";
		assembled += u8"#define " + _MacroBuildMinute + u8" " + ToStringFixedWidth(tm.tm_min) + u8"\n";
		assembled += u8"#define " + _MacroBuildSecond + u8" " + ToStringFixedWidth(tm.tm_sec) + u8"\n\n";
		assembled += u8"#define " + _MacroBuildTimeString + u8" \"" + ToStringFixedWidth(tm.tm_hour) + u8":" +
			ToStringFixedWidth(tm.tm_min) + u8":" + ToStringFixedWidth(tm.tm_sec) + u8"\"\n\n";
	}

	return assembled;
}

// Write a build info file (UTF-8)
bool WriteBuildInfoFile(const std::wstring_view& filenameView, const uint64_t& buildNumber, const bool& enableTime)
{
	// Open file
	std::ofstream buildInfoFile(filenameView);
	if (!buildInfoFile.is_open())
	{
		std::cout << "[ERROR]: Could not open file for writing! Do you have write permissions?" << std::endl;
		return false;
	}

	// Assemble all macro defines and values as std::string for writing
	const std::string assembledMacros = AssembleMacroValues(buildNumber, enableTime);

	// Write file header
	buildInfoFile.write(_FileHeader.data(), _FileHeader.size());

	// Write macro defines and values
	buildInfoFile.write(assembledMacros.data(), assembledMacros.size());

	// Write EOF signal
	const std::string eofSignal = u8"/********************** End of generated file **********************/";
	buildInfoFile.write(eofSignal.data(), eofSignal.size());

	// Check if write succeeded
	if (!buildInfoFile.good())
	{
		std::cout << "[ERROR]: Writing to file failed! File may be damaged. Do you have write permissions?" << std::endl;

		buildInfoFile.close();
		return false;
	}

	// Close file
	buildInfoFile.close();

	return true;
}

// Get the arguments as wide strings (UTF-16)
std::vector<std::wstring> GetCommandLineArguments()
{
	// Get arguments as Unicode UTF16
	LPWSTR* argList = nullptr;
	int32_t argc = 0;
	argList = CommandLineToArgvW(GetCommandLineW(), &argc);

	if (argList == nullptr)
	{
		std::cout << "[ERROR]: Could not parse command line arguments!" << std::endl;
		return std::vector<std::wstring>();
	}

	std::vector<std::wstring> commandArguments;
	for (int32_t i = 0; i < argc; i++)
		commandArguments.push_back(argList[i]);

	LocalFree(argList);

	return commandArguments;
}

// Print help text for command line arguments
void PrintHelpText()
{
	std::cout << std::endl;
	std::cout << "USAGE:" << std::endl;
	std::cout << R"(  BuildInfoGenerator [/h | /help] | ([/time] [/reset] /out "file"))" << std::endl << std::endl;

	std::cout << "OPTIONS:" << std::endl;
	std::cout << "  /h, /help        Display this help message." << std::endl;
	std::cout << "  /time            Write build time and date to generated file." << std::endl;
	std::cout << "  /reset           Reset the generated file and set the build number" << std::endl;
	std::cout << "                   back to zero." << std::endl;
	std::cout << R"(  /out "file"      Specify the output file (relative or absolute).)" << std::endl << std::endl;
}

// Parse all command line arguments and output results. Return false if parsing failed.
bool ParseCommandLineArguments(std::vector<std::wstring> arguments, bool& showHelp_out, std::filesystem::path& filepath_out, bool& enableTime_out, bool& reset_out)
{
	// Set output values to default state
	filepath_out = L"";
	showHelp_out = false;
	enableTime_out = false;
	reset_out = false;

	// Check for at least one user argument
	if (arguments.size() <= 1)
	{
		// No user arguments passed, only executable path from OS
		std::cout << "[ERROR]: No command line arguments specified!" << std::endl;
		return false;
	}

	// Erase first argument (executable path passed by OS), since it's not needed
	arguments.erase(arguments.begin());

	// Parse all arguments one by one
	bool argumentOutParsed = false;
	for (uint64_t i = 0; i < arguments.size(); i++)
	{
		if (arguments[i] == L"/help" || arguments[i] == L"/h")
		{
			showHelp_out = true;
		}
		else if (arguments[i] == L"/reset")
		{
			reset_out = true;
		}
		else if (arguments[i] == L"/time")
		{
			enableTime_out = true;
		}
		else if (arguments[i] == L"/out" && !argumentOutParsed) // Only parse "/out" once
		{
			argumentOutParsed = true; // Allow only one "/out" argument

			// Next argument should be the filename, check if another argument is present
			if ((i + 1) >= arguments.size())
			{
				std::cout << "[ERROR]: No filename after \"/out\" specified!" << std::endl;
				return false;
			}

			// Parse filename
			if (arguments[i + 1] == L"")
			{
				// Empty filename
				std::cout << "[ERROR]: No filename after \"/out\" specified!" << std::endl;
				return false;
			}

			filepath_out = arguments[i + 1];

			// Skip next argument (filename), it got already parsed here
			i++;
			continue;
		}
		else
		{
			// Unexpected argument
			std::wcout << L"[ERROR]: Unexpected argument \"" << arguments[i] << L"\"." << std::endl;
			return false;
		}
	}

	// Check if filename got parsed (not needed if only help should be shown)
	if (!showHelp_out && !argumentOutParsed)
	{
		// No filename specified
		std::cout << "[ERROR]: No output file specified!" << std::endl;
		return false;
	}

	return true;
}

// Main routine
int main()
{
	std::cout << "Build Info Generator: ";

	// Get command line arguments
	const std::vector<std::wstring> commandArguments = GetCommandLineArguments();

	// Parse user arguments
	std::filesystem::path	filepath = L"";
	bool			showHelp = false;
	bool			enableTime = false;
	bool			reset = false;

	if (!ParseCommandLineArguments(commandArguments, showHelp, filepath, enableTime, reset))
	{
		// Parse failed (message got print inside function), show help and exit
		PrintHelpText();
		return -1;
	}

	// If "/help" argument is specified, ignore all other arguments and only show help text
	if (showHelp)
	{
		std::cout << std::endl;
		PrintHelpText();

		return 0;
	}

	// Make path absolute
	filepath = std::filesystem::absolute(filepath);

	// Check if filename is a directory
	if (std::filesystem::is_directory(filepath))
	{
		std::cout << "[ERROR]: Filename is an existing directory! Please specify a file." << std::endl;
		return -1;
	}

	// Print update
	std::cout << "Generating... ";

	// Check if "/reset" is specified or file doesn't exist yet
	if (reset || !std::filesystem::exists(filepath))
	{
		// Create new file
		if (!WriteBuildInfoFile(filepath.wstring(), 0, enableTime))
			return -1; // Write failed, error message got printed inside function
	}
	else
	{
		// File exists and should be updated (no reset)
		uint64_t buildNumber = 0;
		bool pauseUpdates = false;

		// Read build info from file
		if (!ReadBuildInfoFile(filepath.wstring(), buildNumber, pauseUpdates))
			return -1; // Read failed, error message got printed inside function

		// Check if pause macro is enabled
		if (pauseUpdates)
		{
			// Skip all updates and exit
			std::cout << "[INFO]: Pause is enabled, no updates on file performed. [DONE]" << std::endl;
			return 0;
		}

		// Increment build number
		buildNumber++;

		// Write updated file
		if (!WriteBuildInfoFile(filepath.wstring(), buildNumber, enableTime))
			return -1; // Write failed, error message got printed inside function
	}

	std::cout << "[DONE]" << std::endl;

	return 0;
}
