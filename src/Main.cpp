/********************************************************************/
/*																	*/
/*						(C) 2021 Marc Schöndorf						*/
/*																	*/
/*	Automatically creates a header file with						*/
/*	incrementing build number and time info							*/
/********************************************************************/
/*		     Updated 2021, original version from 2019				*/
/********************************************************************/

// ToDo: Add license


#include <iostream>
#include <fstream>
#include <sstream>
#include <cstdint>
#include <string>
#include <vector>
#include <filesystem>
#include <Windows.h>

// Macro names (should be ASCII, because currently the macro parser can't handle Unicode chars. The file is still written as UTF-8)
const std::string _MacroPause = "BUILD_INFO_GENERATOR_PAUSE";

const std::string _MacroBuildNumber = "BUILD_INFO_GENERATOR_BUILD_NUMBER";

const std::string _MacroBuildDay = "BUILD_INFO_GENERATOR_DAY";
const std::string _MacroBuildMonth = "BUILD_INFO_GENERATOR_MONTH";
const std::string _MacroBuildYear = "BUILD_INFO_GENERATOR_YEAR";

const std::string _MacroBuildHour = "BUILD_INFO_GENERATOR_HOUR";
const std::string _MacroBuildMinute = "BUILD_INFO_GENERATOR_MINUTE";
const std::string _MacroBuildSecond = "BUILD_INFO_GENERATOR_SECOND";

// File header to write (UTF-8)
const std::string _FileHeader =
u8"/********************************************************************/\n" \
u8"/*                                                                  */\n" \
u8"/*                 Generated by Build Info Generator                */\n" \
u8"/*                      (C) 2021 Marc Schöndorf                     */\n" \
u8"/*                                                                  */\n" \
u8"/*  All modifications to this file                                  */\n" \
u8"/*  will be replaced on next run.                                   */\n" \
u8"/********************************************************************/\n\n" \
u8"#pragma once\n\n" \
u8"// To disable updates to this file, set \"" + _MacroPause + "\" to \"1\".\n" \
u8"#define " + _MacroPause + " 0\n\n" \
u8"// Generated info\n";


// Parse the macro in the current line
bool ParseMacroInCurrentLine(const std::string_view& currentLineView, const size_t& startPoint, uint64_t& parsedInteger_out)
{
	// Search for first space beginning at first char of macro name (startPoint). The number begins after the found space
	const size_t spacePos = currentLineView.find(' ', startPoint);
	if (spacePos == std::string::npos)
	{
		// Space not found
		std::cout << "[ERROR]: Unknown Syntax after \"" << currentLineView.substr(startPoint) << "\"! Expected a space. File may be damaged, try \"/reset\"." << std::endl;
		return false;
	}

	// Get the number (it begins one char after found space until end of line)
	std::string numberString = currentLineView.substr(spacePos + 1).data();
	if (numberString == "")
	{
		// No value found
		std::cout << "[ERROR]: Unknown Syntax after \"" << currentLineView.substr(startPoint) << "\"! Expected a value. File may be damaged, try \"/reset\"." << std::endl;
		return false;
	}

	// Remove \n or \r at the end of line
	numberString.erase(std::remove(numberString.begin(), numberString.end(), '\n'), numberString.end());
	numberString.erase(std::remove(numberString.begin(), numberString.end(), '\r'), numberString.end());

	// Try converting the string to integer
	try {
		parsedInteger_out = std::stoull(numberString);
	}
	catch (...) {
		std::cout << "[ERROR]: Could not parse value of \"" << currentLineView.substr(startPoint) << "\". File may be damaged, try \"/reset\"." << std::endl;
		return false;
	}

	return true;
}

// Read a build info file and return the parsed information. The function aborts when a macro cannot be parsed
bool ReadBuildInfoFile(const std::wstring_view& filenameView, uint64_t& buildNumber_out, bool& pauseEnabled_out)
{
	// Open file
	std::ifstream buildInfoFile(filenameView);
	if (!buildInfoFile.is_open())
	{
		// Not found, file may be corrupted or encoded
		std::cout << "[ERROR]: File seems to exist but it could not be opened for reading! Is the specified path a folder?" << std::endl;
		return false;
	}

	// Read file
	std::pair<bool, uint64_t> macroBuildNumberResult(false, 0); // (found, data)
	std::pair<bool, uint64_t> macroPauseResult(false, 0); // (found, data)
	std::string currentLine = "";

	while (std::getline(buildInfoFile, currentLine)) // Read file line by line
	{
		// Skip all empty lines and lines that don't start with '#'
		if (currentLine.size() == 0 || currentLine[0] != '#')
			continue;

		// Search for build number macro in current line if it was not found yet
		if (!macroBuildNumberResult.first) // Already found?
		{
			const size_t macroNameStartPoint = currentLine.find(_MacroBuildNumber);
			if (macroNameStartPoint != std::string::npos)
			{
				// Macro found, try to parse it
				if (!ParseMacroInCurrentLine(currentLine, macroNameStartPoint, macroBuildNumberResult.second))
				{
					// Parse failed, error message got printed inside function
					buildInfoFile.close();
					return false;
				}

				// Macro found and parsed successfully
				macroBuildNumberResult.first = true;
			}
		}

		// Search for pause macro in current line if it was not found yet
		if (!macroPauseResult.first) // Already found?
		{
			const size_t macroNameStartPoint = currentLine.find(_MacroPause);
			if (macroNameStartPoint != std::string::npos)
			{
				// Macro found, try to parse it
				if (!ParseMacroInCurrentLine(currentLine, macroNameStartPoint, macroPauseResult.second))
				{
					// Parse failed, error message got printed inside function
					buildInfoFile.close();
					return false;
				}

				// Macro found and parsed successfully
				macroPauseResult.first = true;
			}
		}

		// Break loop when both macros are found and parsed, since there are not more than those two macros
		if (macroBuildNumberResult.first && macroPauseResult.first)
			break;
	}

	// Close the file
	buildInfoFile.close();

	// Check if build number macro was found (necessary)
	if (!macroBuildNumberResult.first)
	{
		std::cout << "[ERROR]: Macro \"" << _MacroBuildNumber << "\" not found! File may be damaged, try \"/reset\"." << std::endl;
		return false;
	}

	// Set output value
	buildNumber_out = macroBuildNumberResult.second;

	// Check if pause macro was found (optional). If not, set pause to disabled
	if (macroPauseResult.first)
		pauseEnabled_out = macroPauseResult.second == 0 ? false : true;
	else
		pauseEnabled_out = false;

	return true;
}

// Return the number as string with fixed digit count
std::string ToStringFixedWidth(const int64_t& integer, const uint8_t& width = 2)
{
	std::ostringstream ss;
	ss << std::setw(width) << std::setfill('0') << integer;

	return ss.str();
}

// Assemble the string which contains all macro defines (used by WriteBuildNumberFile)
std::string AssembleMacroValues(const uint64_t& buildNumber, const bool& enableTime)
{
	// Assemble string
	std::string assembled = u8"";

	assembled += u8"#define " + _MacroBuildNumber + u8" " + std::to_string(buildNumber) + u8"\n\n";

	if (enableTime)
	{
		// Get current date and time
		std::tm tm = {};
		const auto timePoint = std::chrono::system_clock::now();
		const std::time_t timeT = std::chrono::system_clock::to_time_t(timePoint);
		localtime_s(&tm, &timeT);

		// Write time and date
		assembled += u8"#define " + _MacroBuildDay + u8" " + ToStringFixedWidth(tm.tm_mday) + u8"\n";
		assembled += u8"#define " + _MacroBuildMonth + u8" " + ToStringFixedWidth(tm.tm_mon + 1LL) + u8"\n";
		assembled += u8"#define " + _MacroBuildYear + u8" " + ToStringFixedWidth(tm.tm_year + 1900LL) + u8"\n\n";

		assembled += u8"#define " + _MacroBuildHour + u8" " + ToStringFixedWidth(tm.tm_hour) + u8"\n";
		assembled += u8"#define " + _MacroBuildMinute + u8" " + ToStringFixedWidth(tm.tm_min) + u8"\n";
		assembled += u8"#define " + _MacroBuildSecond + u8" " + ToStringFixedWidth(tm.tm_sec) + u8"\n\n";
	}

	return assembled;
}

// Write a build info file (UTF-8)
bool WriteBuildInfoFile(const std::wstring_view& filenameView, const uint64_t& buildNumber, const bool& enableTime)
{
	// Open file
	std::ofstream buildInfoFile(filenameView);
	if (!buildInfoFile.is_open())
	{
		std::cout << "[ERROR]: Could not open file for writing! Do you have write permissions?" << std::endl;
		return false;
	}

	// Assemble all macro defines and values as std::string for writing
	const std::string assembledMacros = AssembleMacroValues(buildNumber, enableTime);

	// Write file header
	buildInfoFile.write(_FileHeader.data(), _FileHeader.size());

	// Write macro defines and values
	buildInfoFile.write(assembledMacros.data(), assembledMacros.size());

	// Write EOF signal
	const std::string eofSignal = u8"/********************** End of generated file **********************/";
	buildInfoFile.write(eofSignal.data(), eofSignal.size());

	// Check if write succeeded
	if (!buildInfoFile.good())
	{
		std::cout << "[ERROR]: Writing to file failed! File may be damaged. Do you have write permissions?" << std::endl;

		buildInfoFile.close();
		return false;
	}

	// Close file
	buildInfoFile.close();

	return true;
}

// Get the arguments as wide strings (UTF16)
std::vector<std::wstring> GetCommandLineArguments()
{
	// Get arguments as Unicode UTF16
	LPWSTR* argList = nullptr;
	int32_t argc = 0;
	argList = CommandLineToArgvW(GetCommandLineW(), &argc);

	if (argList == nullptr)
	{
		std::cout << "[ERROR]: Could not parse command line arguments!" << std::endl;
		return std::vector<std::wstring>();
	}

	std::vector<std::wstring> commandArguments;
	for (int32_t i = 0; i < argc; i++)
		commandArguments.push_back(argList[i]);

	LocalFree(argList);

	return commandArguments;
}

// Print help text for command line arguments
void PrintHelpText()
{
	std::cout << std::endl;
	std::cout << "USAGE:" << std::endl;
	std::cout << "	BuildInfoGenerator [/h | /help] | ([/time] [/reset] \"filename\")" << std::endl << std::endl;

	std::cout << "OPTIONS:" << std::endl;
	std::cout << "	/h, /help	Display this help message." << std::endl;
	std::cout << "	/time		Write build time and date to generated file." << std::endl;
	std::cout << "	/reset		Reset the generated file and set the BuildNumber back to 0." << std::endl << std::endl;
}

// ToDO: Add /out parameter followed by filename to prevent accidental file creation at "/he" for example
// Parse all command line arguments and output results. Returns false if parsing failed
bool ParseCommandLineArguments(std::vector<std::wstring> arguments, bool& showHelp_out, std::wstring& filename_out, bool& enableTime_out, bool& reset_out)
{
	// Set output values to default state
	filename_out = L"";
	showHelp_out = false;
	enableTime_out = false;
	reset_out = false;

	// Check for at least one user argument
	if (arguments.size() <= 1)
	{
		// No user arguments passed, only executable path from OS
		std::cout << "[ERROR]: No command line arguments specified!" << std::endl;
		return false;
	}

	// Erase first argument (executable path passed by OS), since it's not needed
	arguments.erase(arguments.begin());

	// Parse all arguments one by one
	bool filenameParsed = false;
	for (const auto& arg : arguments)
	{
		if (arg == L"/help" || arg == L"/h")
		{
			showHelp_out = true;
		}
		else if (arg == L"/reset")
		{
			reset_out = true;
		}
		else if (arg == L"/time")
		{
			enableTime_out = true;
		}
		else // Should be filename
		{
			// If filename got already parsed, this is an unexpected argument
			if (filenameParsed)
			{
				std::wcout << L"[ERROR]: Unexpected argument: \"" << arg << L"\"" << std::endl;
				return false;
			}

			filename_out = arg;
			filenameParsed = true;
		}
	}

	return true;
}

// Main routine
int main()
{
	std::cout << "Build Info Generator: ";

	// Get command line arguments
	const std::vector<std::wstring> commandArguments = GetCommandLineArguments();

	// Parse user arguments
	std::wstring	filename = L"";
	bool			showHelp = false;
	bool			enableTime = false;
	bool			reset = false;

	if (!ParseCommandLineArguments(commandArguments, showHelp, filename, enableTime, reset))
	{
		// Parse failed (message got print inside function), show help and exit
		PrintHelpText();
		return -1;
	}

	// If "/help" argument is specified, ignore all other arguments and only show help text
	if (showHelp)
	{
		std::cout << std::endl;
		PrintHelpText();

		return 0;
	}

	// Check if filename is specified. Needed for all other arguments
	if (filename == L"")
	{
		std::cout << "[ERROR]: No filename specified!" << std::endl;
		return -1;
	}

	// Print update
	std::cout << "Generating... ";

	// Check if "/reset" is specified or file doesn't exist yet
	if (reset || !std::filesystem::exists(filename))
	{
		// Create new file
		if (!WriteBuildInfoFile(filename, 0, enableTime))
			return -1; // Write failed, error message got printed inside function
	}
	else
	{
		// File exists and should be updated (no reset)
		uint64_t buildNumber = 0;
		bool pauseUpdates = false;

		// Read build info from file
		if (!ReadBuildInfoFile(filename, buildNumber, pauseUpdates))
			return -1; // Read failed, error message got printed inside function

		// Check if pause macro is enabled
		if (pauseUpdates)
		{
			// Skip all updates and exit
			std::cout << "[INFO]: Pause is enabled, no updates on file performed. [DONE]" << std::endl;
			return 0;
		}

		// Increment build number
		buildNumber++;

		// Write updated file
		if (!WriteBuildInfoFile(filename, buildNumber, enableTime))
			return -1; // Write failed, error message got printed inside function
	}

	std::cout << "[DONE]" << std::endl;

	return 0;
}
